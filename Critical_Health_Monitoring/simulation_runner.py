import collections
import time
import Read_Signal 
from Simulation_Config import *
from serial_logger import SerialLogger
from .health_monitor import HealthMonitor

master_pressure_window = collections.deque()
caliper_fr_pressure_window = collections.deque() # Still generated by Read_Signal (but not used by monitor)
caliper_fl_pressure_window = collections.deque() # Still generated by Read_Signal (but not used by monitor)



# --- Encapsulated Simulation Logic ---
def run_simulation():
    """
    Runs the braking health detection simulation, focusing on the strictly defined signals.
    This function simulates real-time data reception and processing,
    with processing occurring every CAN_SAMPLE_INTERVAL_S.
    """
    print(f"--- Simulating Braking System Health Monitoring for {SIMULATION_DURATION_S}s ---")
    print(f"CAN data simulated to arrive every {CAN_SAMPLE_INTERVAL_S}s.")

    print(f"Simulated signals generated from module: {Read_Signal.__name__}\n")

    # Initialize the braking health monitor
    braking_health_monitor = HealthMonitor()
    
        # --- Serial Port Configuration ---
    # IMPORTANT: Replace 'COMx' with your actual serial port (e.g., 'COM1' on Windows, '/dev/ttyUSB0' on Linux)
    # IMPORTANT: Ensure the baudrate matches your receiving device.
    serial_port_name = 'COM1'  # <--- CHANGE THIS TO YOUR SERIAL PORT
    baud_rate = 9600          # <--- CHANGE THIS TO YOUR BAUD RATE
    
    # Initialize the SerialLogger
    serial_logger = SerialLogger(serial_port_name, baud_rate)
    
    # We will use a simple counter for simulation time, as time.sleep paces the loop
    current_sim_time = 0.0

    while current_sim_time < SIMULATION_DURATION_S:
        # --- Generate simulated CAN signals using YOUR Read_Signal.py functions ---
        # Only generating the strictly defined signals relevant to braking health
        simulated_meter_sw_status_brake_fluid = Read_Signal.generate_simulated_meter_sw_status_brake_fluid(current_sim_time)
        simulated_eng_sw_status_brake_no = Read_Signal.generate_simulated_eng_sw_status_brake_no(current_sim_time)
        simulated_vsa_master_cylinder_pressure = Read_Signal.generate_simulated_vsa_master_cylinder_pressure(current_sim_time, simulated_eng_sw_status_brake_no)
        
      
        
        simulated_vsa_warn_status_brake = Read_Signal.generate_simulated_vsa_warn_status_brake(current_sim_time)
        simulated_vsa_warn_status_abs = Read_Signal.generate_simulated_vsa_warn_status_abs(current_sim_time)
        simulated_vsa_warn_status_puncture = Read_Signal.generate_simulated_vsa_warn_status_puncture(current_sim_time)


    
        # --- Apply Braking Health Monitoring Rules ---
        braking_alert_level, braking_alert_description = braking_health_monitor.check_braking_health(
            current_sim_time,
            simulated_meter_sw_status_brake_fluid,
            simulated_eng_sw_status_brake_no,
            simulated_vsa_master_cylinder_pressure,
            simulated_vsa_warn_status_brake,
            simulated_vsa_warn_status_abs,
            simulated_vsa_warn_status_puncture
        )

        # --- Print Simulation Status ---
        print(f"Time: {current_sim_time:0.1f}s")
        print(f"  --- Braking System Health ---")
        print(f"  Brake Fluid: {'LOW' if simulated_meter_sw_status_brake_fluid else 'Normal'} | "
              f"Brake Pedal: {'PRESSED' if simulated_eng_sw_status_brake_no else 'RELEASED'}")
        print(f"  Master Cylinder Pressure: {simulated_vsa_master_cylinder_pressure:7.1f} kPa") # Removed MC fail status print
        # Print caliper pressures for context, even if not directly used by monitor rules
        
        print(f"  Warnings: BRAKE={'Active' if simulated_vsa_warn_status_brake else 'Inactive'}, ABS={'Active' if simulated_vsa_warn_status_abs else 'Inactive'}, PUNCTURE={'Active' if simulated_vsa_warn_status_puncture else 'Inactive'}") # Removed ABS_MIL
        print(f"  Braking Health Alert: {braking_alert_level} | Description: {braking_alert_description}\n")

                # --- Serial Output for Alerts ---
        if serial_logger.is_active() and braking_alert_level != ALERT_LEVEL_NONE:
            message = f"ALERT: {braking_alert_level} - {braking_alert_description}" # Newline added by log_alert
            serial_logger.log_alert(message)

        # Advance simulation time for the next iteration
        current_sim_time += CAN_SAMPLE_INTERVAL_S
        
        # Pause for the specified interval to simulate real-time data arrival
        time.sleep(CAN_SAMPLE_INTERVAL_S)

    print("\n--- Simulation Ended ---")

        # --- Close Serial Port ---
    serial_logger.close()
